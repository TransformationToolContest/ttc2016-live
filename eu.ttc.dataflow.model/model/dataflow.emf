@namespace(uri="http://transformation-tool-contest.eu/2016/dataflow", prefix="df")
package dataflow;

// TODO: allow for placing expressions inside more places (would require spending more time with Sirius)

class Model {
	val Element[*] elements;
}

abstract class Element {
	attr String description;

	// target element that will consume the produced rows
	ref Element target;
}

/// INSTANCE HANDLING  //////////////////////////////////////////////////////////////////

// As initial node: lists all instances of a type
// As intermediate node: for each input row, duplicates it with a different instance of a type 
class AllInstances extends Element {
	attr String[1] field;
	attr String[?] nsURI;    // can be omitted (interpreter would need to know somehow just from the type)
	attr String[1] typeName;
}

// As initial node: creates a row with one instance of a type
// As intermediate node: for each input row, creates one instance of the type
class NewInstance extends Element {
	attr String field;
	attr String[?] nsURI;    // can be omitted (interpreter would need to know somehow just from the type)
	attr String[1] typeName;
}

// STREAM PROCESSING ////////////////////////////////////////////////////////////////////

// Not valid as initial node
// As intermediate node: splits a stream into two according to a condition
class Filter extends Element {
	attr String filterByField;

    // if set, this will consume the *rejected* rows
	ref Element rejectTarget;
}

// Not valid as initial node
// Reads all incoming rows and then sorts by ascending value of the expression
class Sort extends Element {
	attr String sortByField;
}

// Not valid as initial node
// Does cartesian product of two streams
class Product extends Element {}

// FEATURE ///////////////////////////////////////////////////////////////////////////////////

// Retrieves a specific feature in the object in 'field' and places it in the 'valueField'
class GetFeature extends Element {
	attr String objectField; // field that has the object to work with
    attr String valueField;  // field that will have the retrieved value
	attr String feature;
}

// Sets a specific feature in the object in 'field' to the value in the 'valueField'
class SetFeature extends Element {
	attr String objectField; // field that has the object to work with
	attr String valueField; // expression to compute the value to be set
	attr String feature;
}

// Unsets a specific feature in the object in 'field'
class UnsetFeature extends Element {
	attr String objectField; // field that has the object to work with
	attr String feature;
}

// CONTAINERS ////////////////////////////////////////////////////////////////////////////////

class NewContainer extends Element {
	attr String listField;
	attr ContainerType containerType;
}

// Adds an element to a container
class AddToContainer extends Element {
	attr String listField;
	attr String valueField;

	// if not set, adds at the end
	attr String positionExpression;
}

// we don't have remove/clear (we're only targeting exogenous transformations right now)

// EXPRESSION LANGUAGE ///////////////////////////////////////////////////////////////////////

class Evaluate extends Element {
	attr String field;
	val Expression expression;
}

abstract class Expression {}

class IntegerLiteral extends Expression {
	attr int value;
}

class BooleanLiteral extends Expression {
	attr boolean value;
}

class RealLiteral extends Expression {
	attr double value;
}

class StringLiteral extends Expression {
	attr String value;
}

class FieldReference extends Expression {
	attr String field;
}

class UnaryOperation extends Expression {
	attr UnaryOperator operator;
	val Expression expression;
}

class BinaryOperation extends Expression {
	attr BinaryOperator operator;
	val Expression leftExpression;
	val Expression rightExpression;
}

enum UnaryOperator {
	NOT; NEGATION; SIZE;
}

enum BinaryOperator {
	EQ; NE; GT; GE; LT; LE; IS_DEFINED; IS_UNDEFINED; AND; OR; XOR; ADD; SUBTRACT; MULTIPLY; DIVIDE;
}

enum ContainerType {
	LIST; SET;
}
