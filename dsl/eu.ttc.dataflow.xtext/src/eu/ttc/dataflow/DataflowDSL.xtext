// automatically generated by Xtext
grammar eu.ttc.dataflow.DataflowDSL with org.eclipse.xtext.common.Terminals

import "http://transformation-tool-contest.eu/2016/dataflow" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model returns Model:
	{Model}
	(elements+=Element)*
;

Element:
	AllInstances | NewInstance | Filter | Sort | Copy | Product | GetFeature | SetFeature | NewContainer | AddToContainer | ForEach | CollectBy | Evaluate;

AllInstances:
	'AllInstances'
	name=ID
	'{'
		('field' field=ID
		|'type' (model=ID '!')? (packageName=ID '::')? typeName=ID
		| 'target' target=[Element])*
	'}';

NewInstance:
	'NewInstance'
	name=ID
	'{'
		('field' instanceField=ID
		|'key' key=ConditionalExpression
		|'type' (model=ID '!')? (packageName=ID '::')? typeName=ID
		|'target' target=[Element])*
	'}';

Filter:
	'Filter'
	name=ID
	'{'
		('filterBy' filterBy=ConditionalExpression
		|'target' target=[Element]
		|'rejectTarget' rejectTarget=[Element])*
	'}';

Copy:
	'Copy'
	name=ID
	'{'
		('target' target=[Element]
		|'copyTarget' copyTarget=[Element])*
	'}';

Sort:
	'Sort'
	name=ID
	'{'
		('sortBy' sortBy=ConditionalExpression
		|'target' target=[Element])*
	'}';

Product:
	'Product'
	name=ID
	'{'
		('target' target=[Element])?
	'}';

GetFeature:
	'GetFeature'
	name=ID
	'{'
		('objectField' objectField=ID
		|'valueField' valueField=ID
		|'feature' feature=ID
		|'target' target=[Element])*
	'}';

SetFeature:
	'SetFeature'
	name=ID
	'{'
		('field' objectField=ID
		|'value' value=ConditionalExpression
		|'feature' feature=ID
		|'target' target=[Element])*
	'}';

NewContainer:
	'NewContainer'
	name=ID
	'{'
		('field' listField=ID)?
		('containerType' containerType=ContainerType)?
		('target' target=[Element])?
	'}';

AddToContainer:
	'AddToContainer'
	name=ID
	'{'
		('field' listField=ID
		|'value' value=ConditionalExpression
		|'position' position=ConditionalExpression
		|'target' target=[Element])*
	'}';

ForEach:
	'ForEach'
	name=ID
	'{'
		('listField' listField=ID
		|'itemField' itemField=ID
		|'positionField' positionField=ID
		|'target' target=[Element])*
	'}';

CollectBy:
	'CollectBy'
	name=ID
	'{'
		('field' elementField=ID
		|'collectBy' collectBy=ConditionalExpression
		|'target' target=[Element])*
	'}';

Evaluate:
	'Evaluate'
	name=ID
	'{'
		('field' field=ID
		|'expression' expression=ConditionalExpression
		|'target' target=[Element])*
	'}';

enum ContainerType returns ContainerType: LIST='list' | SET='set';

ConditionalExpression returns Expression:
	'if' OrExpression {ConditionalExpression.conditionExpression=current} 'then' thenExpression=OrExpression 'else' elseExpression=OrExpression
	| OrExpression
;

OrExpression returns Expression:
	AndExpression ({BinaryOperation.leftExpression=current} operator=OrOperator rightExpression=AndExpression)*
;

AndExpression returns Expression:
	EqualityExpression ({BinaryOperation.leftExpression=current} operator=AndOperator rightExpression=EqualityExpression)*
;

EqualityExpression returns Expression:
	RelationalExpression ({BinaryOperation.leftExpression=current} operator=EqualityOperator rightExpression=RelationalExpression)*
;

RelationalExpression returns Expression:
	AdditiveExpression ({BinaryOperation.leftExpression=current} operator=RelationalOperator rightExpression=AdditiveExpression)*
;

AdditiveExpression returns Expression:
	MultiplicativeExpression ({BinaryOperation.leftExpression=current} operator=AdditiveOperator rightExpression=MultiplicativeExpression)*
;

MultiplicativeExpression returns Expression:
	UnaryExpression ({BinaryOperation.leftExpression=current} operator=MultiplicativeOperator rightExpression=UnaryExpression)*
;

UnaryExpression returns Expression:
	{UnaryOperation} operator=UnaryOperator expression=UnaryExpression
	| FeatureCallExpression
;

FeatureCallExpression returns Expression:
	PrimaryExpression ({FeatureCall.targetExpression=current} '.' feature=ID ('(' (parameters+=OrExpression (',' parameters+=OrExpression )*)? ')')?)*
;

PrimaryExpression returns Expression:
	{IntegerLiteral} value=EInt
	| {BooleanLiteral} value=EBoolean
	| {RealLiteral} value=EDouble
	| {StringLiteral} value=STRING
	| {FieldReference} field=ID
	| '(' OrExpression ')'
	;

EInt returns ecore::EInt:
	INT;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

EDouble returns ecore::EDouble:
	INT? '.' INT (('E'|'e') '-'? INT)?;

enum OrOperator returns BinaryOperator : OR='or';
enum AndOperator returns BinaryOperator : AND='and';
enum EqualityOperator returns BinaryOperator : EQ='=' | NE='!=' ;
enum RelationalOperator returns BinaryOperator : GT = '>' | GE = '>=' | LT = '<' | LE = '<=' ;
enum AdditiveOperator returns BinaryOperator : ADD='+' | SUBTRACT='-';
enum MultiplicativeOperator returns BinaryOperator : MULTIPLY = '*' | DIVIDE = '/' | MODULO = '%';

enum UnaryOperator returns UnaryOperator:
	NOT = 'not' | NEGATION = '-'
;
